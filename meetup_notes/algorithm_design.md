A brief description of algorithm design paradigms. Not all algorithms follow these four algorithm design paradigms. They serve only as a general guideline.

# Brute Force algorithm

**Description**: It generates all possible solutions to the problem and checks every solution whether the possible solution solve the problem.

**Analogy**: To break a number lock, you turn the digits on the number lock from 1 to 9 systematically to find the password.

**Pros**: This algorithm will always work and it is the most basic for all programmers.

**Cons**: Due to huge generation of all possible soltuions, it is the most ineffecient way in solving the problem.

# Greedy algorithm

**Description**: It takes the best possible option at each step.

**Analogy**: When finding change for the person with the minimal spend of coins, you give the highest value coin first and follow by the next
highest coin value. Therefore, 70 cents change will be one 50 cents coin follow by one 20 cents coin instead of fourteen 5 cents coins.

**Pros**: It is the most optimal way of solving the problem if the problem can be solved using greedy.

**Cons**: There are situations by which picking the best option at that point in time will not result in the overall best output.

# Divide and Conquer algorithm

**Description**: It breaks down the problem into multiple sub-problems of the same type and runs a repetitive function for each sub-problem.

**Analogy**: If you cannot carry 50 chairs at one go, you divide the chairs in batches of 5 and repeatedly carry 5 chairs each time to 
accomplish the task of carrying 50 chairs.

**Pros**: It can use simple repetitive functions to solve complex problem.

**Cons**: It assumes that the problem can be divided into repeative sub-tasks.

# Dynamic Programming

Covered later on.
